<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<link rel="stylesheet"
		href="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.4.3/css/ol.css" type="text/css">
	<link rel="stylesheet" href="css/menu.css" type="text/css">
	<style>
		.map {
			position: absolute;
			width: 100%;
			height: 100%;
			left: 0px;
			top: 0px;
			z-index: 0;
		}

		.overlay {
			display: flex;
			flex-direction: column;
			justify-content: space-around;
			position: absolute;
			width: 30%;
			height: 98%;
			left: 1%;
			top: 1%;
			z-index: 0;
		}

		.title {
			display: flex;
			position: relative;
			height: 10%;
			width: 100%;
			background-color: #FFFFFF;
			padding: 5px;
			z-index: 0;
		}

		.title_image {
			height: 100%
		}

		.title_text {
			padding: 0px;
			height: 100%;
			vertical-align: middle;
			background-color: #FF8080;
		}

		.caption {
			display: flex;
			height: 20%;
			width: 100%;
			background-color: #FFFFFF;
			padding: 5px;
			align-items: center;
			z-index: 0;
		}

		.chart {
			width: 100%;
			height: 30%;
			background-color: #FFFFFF;
			padding: 5px;
			z-index: 0;
		}

		.legend {
			height: 15%;
			width: 100%;
			background-color: #FFFFFF;
			padding: 5px;
			z-index: 0;
		}

		.ol-zoom {
			left: unset;
			right: 8px;
		}
	</style>
	<script type="text/javascript" src="js/InteractiveVisualization.js"></script>
	<script type="text/javascript" src="js/Menu.js"></script>
	<script type="text/javascript" src="js/FeatureStyle.js"></script>
	<script type="text/javascript" src="js/OBS.js"></script>
	<script src="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.4.3/build/ol.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>

	<title>OpenBikeSensor Visualisierung: Stra&szlig;enabschnitte</title>
</head>

<body>
	<div id="map" class="map"></div>
	<div id="overlay" class="overlay">
		<div id="title" class="title">
			<div id="title_image"><img src="images/OBS.png" height="100%"></img></div>
			<div id="title_text">
				<h4>Visualisierung: Stra&szlig;enabschnitte </h4>
			</div>
		</div>
		<div id="chart" class="chart"></div>
		<div id="caption" class="caption">
			<b>Bitte einen Streckenabschnitt in der Karte (farbige Linien) anklicken um detailierte Informationen zu
				erhalten.</b>
		</div>
		<div id="legend" class="legend">
			<ul class="main-navigation" , id="vis-menu"></ul>
		</div>
	</div>

	<script type="text/javascript">
		const hist_xa = 0.0;
		const hist_xb = 2.55;
		const hist_dx = 0.25;
		const hist_n = Math.ceil((hist_xb - hist_xa) / hist_dx);

		function histogramLabels() {

			let labels = Array(hist_n);
			for (let i = 0; i < hist_n; i++) {
				let xa = hist_xa + hist_dx * i;
				let xb = xa + hist_dx;
				let xc = xa + 0.5 * hist_dx;
				labels[i] = (xa * 100).toFixed(0) + "-" + (xb * 100).toFixed(0);
			}

			return labels;
		}

		function histogramColors(palette) {

			let colors = Array(hist_n);
			for (let i = 0; i < hist_n; i++) {
				let xc = hist_xa + hist_dx * i;
				colors[i] = palette.rgb_hex(xc);
			}

			return colors;
		}

		function histogram(samples) {
			let binCounts = new Array(hist_n).fill(0);

			for (let i = 0; i < samples.length; i++) {
				let v = samples[i];
				let j = Math.floor((v - hist_xa) / hist_dx);
				if (j >= 0 && j < hist_n) {
					binCounts[j]++;
				}
			}

			return binCounts;
		}


		function annotation_verbose(feature) {
			let s = "";

			s += "name: " + feature.get('name') + "\n";
			s += "way_id: " + feature.get('way_id') + "\n";
			s += "direction: " + feature.get('direction') + "\n";
			s += "zone: " + feature.get('zone') + "\n";
			s += "valid: " + feature.get('valid') + "\n";

			d = feature.get('distance_overtaker_limit');
			s += "distance_overtaker_limit: " + ((d == null) ? "n/a" : d.toFixed(2)) + " m \n";

			s += "<hr></hr>statistics\n";

			d = feature.get('distance_overtaker_mean');
			s += "distance_overtaker_mean: " + ((d == null) ? "n/a" : d.toFixed(2)) + " m \n";

			d = feature.get('distance_overtaker_median');
			s += "distance_overtaker_median: " + ((d == null) ? "n/a" : d.toFixed(2)) + " m \n";

			d = feature.get('distance_overtaker_minimum');
			s += "distance_overtaker_minimum: " + ((d == null) ? "n/a" : d.toFixed(2)) + " m \n";

			d = feature.get('distance_overtaker_n');
			s += "distance_overtaker_n: " + ((d == null) ? "n/a" : d.toFixed(0)) + "\n";

			d = feature.get('distance_overtaker_n_above_limit');
			s += "distance_overtaker_n_above_limit: " + ((d == null) ? "n/a" : d.toFixed(0)) + "\n";

			d = feature.get('distance_overtaker_n_below_limit');
			s += "distance_overtaker_n_below_limit: " + ((d == null) ? "n/a" : d.toFixed(0)) + "\n";

			let n_below = feature.get('distance_overtaker_n_below_limit');
			let n = feature.get('distance_overtaker_n');
			let p = n_below / n * 100.0;
			s += "overtakers below limit: " + ((p == null) ? "n/a" : p.toFixed(1)) + " %\n";

			return s;
		}

		function annotation(feature) {

			let s = "<table>";

			s += "<tr><td>Stra&szlig;enname:</td><td><a href=\"https://www.openstreetmap.org/way/" + feature.get('way_id') + "\" target=\"_blank\">" + feature.get('name')
				+ "</a></td></tr>";
			d = feature.get('distance_overtaker_limit');
			s += "<tr><td>Mindest&uuml;berholabstand:</td><td>" + ((d == null) ? "n/a" : d.toFixed(2)) + " m </td>";

			d = feature.get('distance_overtaker_n');
			s += "<tr><td>Anzahl Messungen:</td><td>" + ((d == null) ? "n/a" : d.toFixed(0)) + "</td></tr>";

			let n_below = feature.get('distance_overtaker_n_below_limit');
			let n = feature.get('distance_overtaker_n');
			let p = n_below / n * 100.0;
			s += "<tr><td>Unterschreitung Mindestabstand:</td><td>" + ((p == null) ? "n/a" : p.toFixed(1)) + "% der &Uuml;berholenden</td></tr>";

			d = feature.get('distance_overtaker_mean');
			s += "<tr><td>Durchschnitt &Uuml;berholabstand:</td><td>" + ((d == null) ? "n/a" : d.toFixed(2)) + " m </td></tr>";

			d = feature.get('distance_overtaker_median');
			s += "<tr><td>Median &Uuml;berholabstand:</td><td>" + ((d == null) ? "n/a" : d.toFixed(2)) + " m </td></tr>";

			d = feature.get('distance_overtaker_minimum');
			s += "<tr><td>Minimum &Uuml;berholabstand:</td><td>" + ((d == null) ? "n/a" : d.toFixed(2)) + " m </td></tr>";

			s += "</table>";

			return s;
		}

		let map = new ol.Map({
			target: 'map',
			layers: [
				new ol.layer.Tile({
					source: new ol.source.OSM({
						url: 'https://tiles.wmflabs.org/bw-mapnik/{z}/{x}/{y}.png',
						crossOrigin: null
					})
				})
			],
			view: new ol.View({
				center: ol.proj.fromLonLat([9.1798000, 48.7759000]),
				zoom: 13
			})
		});

		let dataSource = new ol.source.Vector({
			format: new ol.format.GeoJSON(),
			url: 'json/roads.json'
		})

		// let defaultStyle = new RoadStyle();
		// let currentStyle = defaultStyle;

		let vectorLayer = new ol.layer.Vector({
			source: dataSource,
			//style: function (feature, resolution){return currentStyle.styleFunction(feature, resolution)}
			style: new ol.style.Style({
				stroke: new ol.style.Stroke({
					color: [0, 0, 0, 255],
					width: 2,
				})
			})
		});

		map.addLayer(vectorLayer);

		let histogramColorsRural = histogramColors(paletteRural).reverse();
		let histogramColorsUrban = histogramColors(paletteUrban).reverse();

		let chartOptions = {
			series: [{
				name: 'Überholende',
				data: Array(hist_n).fill(0)
			}],
			chart: {
				type: 'bar',
				height: 350,
				animations: {
					animateGradually: {
						enabled: false
					}
				}
			},
			plotOptions: {
				bar: {
					horizontal: false,
					columnWidth: '95%',
					endingShape: 'flat',
					distributed: true
				},
			},
			dataLabels: {
				enabled: true
			},
			stroke: {
				show: false,
			},
			xaxis: {
				title: {
					text: 'Überholabstand in Zentimeter'
				},
				categories: histogramLabels().reverse(),
			},
			yaxis: {
				title: {
					text: 'Anzahl Überholende'
				},
				labels: {
					show: false
				}
			},
			fill: {
				opacity: 1,
			},
			legend: {
				show: false
			},
			tooltip: {
				y: {
					formatter: function (val) {
						return val
					}
				}
			}
		};

		let chart = new ApexCharts(document.querySelector("#chart"), chartOptions);
		chart.render();

		let activeFeature = undefined;
		let hoveredFeature = undefined;

		const visualization = new InteractiveVisualization(map, dataSource);

		map.on('singleclick', function (event) {visualization.onSingleClick(event)});

		/*
		map.on('singleclick', function (evt) {
			let feature = map.forEachFeatureAtPixel(evt.pixel,
				function (feature, layer) {
					return feature;
				});

			let resolution = map.getView().getResolution();

			if (activeFeature) {
				activeFeature.setStyle(currentStyle.styleFunction(activeFeature, resolution, false, activeFeature == hoveredFeature));
				activeFeature = undefined;
			}

			if (feature && dataSource.hasFeature(feature)) {
				caption.innerHTML = annotation(feature);
				caption.style.alignItems = "flex-start";

				let zone = feature.get('zone');
				let colors = undefined;
				switch (zone) {
					case "urban":
						colors = histogramColorsUrban;
						break;
					case "rural":
						colors = histogramColorsRural;
						break;
					default:
						colors = histogramColorsUrban;
				}

				chart.updateOptions({
					colors: colors
				});

				let hist = histogram(feature.get('distance_overtaker_measurements')).reverse();

				chart.updateSeries([{
					name: 'Überholende',
					data: hist,
				}]);

				feature.setStyle(currentStyle.styleFunction(feature, resolution, true, feature == hoveredFeature));
				activeFeature = feature;
			}
		});
		*/

		map.on('pointermove', function (event){ visualization.onPointerMove(event)});
		/*
		map.on('pointermove', function (evt) {
			if (evt.dragging) {
				return;
			}

			let feature = map.forEachFeatureAtPixel(map.getEventPixel(evt.originalEvent),
				function (feature, layer) {
					return feature;
				});

			let resolution = map.getView().getResolution();

			if (hoveredFeature) {
				hoveredFeature.setStyle(currentStyle.styleFunction(hoveredFeature, resolution, hoveredFeature == activeFeature, false));
				hoveredFeature = undefined;
			}

			if (feature && dataSource.hasFeature(feature)) {
				feature.setStyle(currentStyle.styleFunction(feature, resolution, feature == activeFeature, true));
				hoveredFeature = feature;
			}
			return feature;
		});
		*/

		const menu = new Menu("vis-menu", visualization);
		menu.addMenu(["Darstellung", "Empfohlen"], "Mittelwert Überholabstand", new RoadStyle_MeanDistance());
		menu.addMenu(["Darstellung", "OpenBikeSensor"], "OpenBikeSensor #1");
		menu.addMenu(["Darstellung", "Zweirat"], "Zweirat #1");
		menu.addMenu(["Darstellung", "Rohdaten"], "Mittelwert Überholabstand", new RoadStyle_MeanDistance());
		menu.addMenu(["Darstellung", "Rohdaten"], "Median Überholabstand");
		menu.addMenu(["Darstellung", "Rohdaten"], "Minimum Überholabstand");
		menu.addMenu(["Darstellung", "Rohdaten"], "Anteil Überholabstand unterschritten");
		menu.addMenu(["Darstellung", "Rohdaten"], "Mindestüberholabstand");
		menu.addMenu(["Darstellung", "Rohdaten"], "Anzahl Überholvorgänge");

		const changeListener = dataSource.once('change', function(event) {
    		if (dataSource.getState() == 'ready') {
				const extent = vectorLayer.getSource().getExtent(); 
				const mapSize = map.getSize();
				const overlay = document.getElementById("overlay");
				const marginLeft = overlay.offsetWidth + overlay.offsetLeft;
    			map.getView().fit(extent, {size: mapSize, padding: [0, 0, 0, marginLeft]}); 
			}
		});

	</script>
</body>

</html>